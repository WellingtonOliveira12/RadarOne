// Schema do RadarOne - Sistema SaaS de Monitoramento de Anúncios
// Pronto para comercialização

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USUÁRIOS E AUTENTICAÇÃO
// ============================================

model User {
  id           String  @id @default(cuid())
  name         String
  email        String  @unique
  phone        String?
  passwordHash String  @map("password_hash")

  // LGPD e Segurança
  cpfEncrypted String? @map("cpf_encrypted") // CPF criptografado (AES-256-GCM)
  cpfLast4     String? @map("cpf_last4") // Últimos 4 dígitos para conferência
  cpfHash      String? @map("cpf_hash") // SHA256 hash do CPF (para validação de duplicação) - NOTA: unique constraint comentada na migration, usar findFirst
  blocked      Boolean @default(false) // Se true, usuário não pode acessar

  // 2FA / MFA (FASE 4.4)
  twoFactorSecret       String?   @map("two_factor_secret") // Secret TOTP (criptografado)
  twoFactorEnabled      Boolean   @default(false) @map("two_factor_enabled")
  twoFactorBackupCodes  String[]  @default([]) @map("two_factor_backup_codes") // Códigos de backup (hashed)
  lastPasswordValidated DateTime? @map("last_password_validated") // Para revalidação de senha

  // Segurança Avançada Admin (FASE 4.4)
  sessionTimeoutMinutes Int?      @map("session_timeout_minutes") // Timeout customizado (null = padrão)
  allowedIps            String[]  @default([]) @map("allowed_ips") // Whitelist de IPs (foundation)
  lastLoginAt           DateTime? @map("last_login_at")
  lastLoginIp           String?   @map("last_login_ip")

  // Controle
  role      UserRole @default(USER)
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  subscriptions        Subscription[]
  monitors             Monitor[]
  usageLogs            UsageLog[]
  telegramAccounts     TelegramAccount[]
  notificationLogs     NotificationLog[]
  notificationSettings NotificationSettings?
  userSessions         UserSession[]
  refreshTokens        RefreshToken[]
  siteExecutionStats   SiteExecutionStats[]

  @@map("users")
}

// ============================================
// REFRESH TOKENS (Sessão Segura)
// ============================================

model RefreshToken {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  tokenHash   String   @unique @map("token_hash") // SHA256 do token (nunca armazena plain text)
  family      String   // Família do token para detectar replay attacks
  expiresAt   DateTime @map("expires_at")
  revokedAt   DateTime? @map("revoked_at") // Se revogado, quando
  replacedBy  String?  @map("replaced_by") // ID do token que substituiu este
  userAgent   String?  @map("user_agent")
  ipAddress   String?  @map("ip_address")
  createdAt   DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([family])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

enum UserRole {
  USER
  ADMIN // Mantido para compatibilidade (equivale a ADMIN_SUPER)
  ADMIN_SUPER // Acesso total
  ADMIN_SUPPORT // Suporte - visualização + ações básicas
  ADMIN_FINANCE // Financeiro - gerenciar assinaturas e cupons
  ADMIN_READ // Apenas leitura (auditoria, relatórios)
}

// ============================================
// TELEGRAM
// ============================================

model TelegramAccount {
  id       String   @id @default(cuid())
  userId   String   @map("user_id")
  chatId   String   @unique @map("chat_id") // chat_id numérico do Telegram
  username String? // @username opcional
  active   Boolean  @default(true)
  linkedAt DateTime @default(now()) @map("linked_at")

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("telegram_accounts")
}

// ============================================
// CONFIGURAÇÕES DE NOTIFICAÇÕES
// ============================================

model NotificationSettings {
  id     String @id @default(cuid())
  userId String @unique @map("user_id")

  // Email sempre ativo (obrigatório)
  emailEnabled Boolean @default(true) @map("email_enabled")

  // Telegram opcional (só ativo se usuario preencher)
  telegramEnabled  Boolean @default(false) @map("telegram_enabled")
  telegramUsername String? @map("telegram_username") // @username normalizado
  telegramChatId   String? @map("telegram_chat_id") // chatId numérico (quando vincular)

  // Link Code para vincular bot Telegram (temporário, expira em 30min)
  telegramLinkCode      String?   @map("telegram_link_code")
  telegramLinkExpiresAt DateTime? @map("telegram_link_expires_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_settings")
}

// ============================================
// PLANOS E ASSINATURAS (SaaS)
// ============================================

model Plan {
  id          String  @id @default(cuid())
  name        String  @unique // FREE, STARTER, PRO, PREMIUM, ULTRA
  slug        String  @unique // free, starter, pro, premium, ultra
  description String?

  // Preços e Períodos
  priceCents    Int    @map("price_cents") // Preço em centavos (ex: 2900 = R$29,00)
  billingPeriod String @map("billing_period") // MONTHLY, YEARLY, SEMIANNUAL
  trialDays     Int    @default(7) @map("trial_days") // Duração do teste grátis

  // Limites do Plano
  maxMonitors     Int @map("max_monitors") // Quantidade máxima de monitores ativos
  maxSites        Int @map("max_sites") // Quantidade de sites diferentes permitidos
  maxAlertsPerDay Int @map("max_alerts_per_day") // Máximo de alertas por dia
  checkInterval   Int @default(60) @map("check_interval") // Intervalo de verificação em minutos

  // Marketing e Ordem
  isRecommended Boolean @default(false) @map("is_recommended") // Destacar em upsell
  priority      Int     @default(0) // Ordenação em listagens (maior = mais importante)

  // Controle
  isActive   Boolean @default(true) @map("is_active")
  isLifetime Boolean @default(false) @map("is_lifetime")

  // Integração Kiwify (futura)
  kiwifyProductId String? @map("kiwify_product_id")
  checkoutUrl     String? @map("checkout_url") // URL do checkout Kiwify/Stripe

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  subscriptions Subscription[]
  coupons       Coupon[]

  @@map("plans")
}

model Subscription {
  id     String @id @default(cuid())
  userId String @map("user_id")
  planId String @map("plan_id")

  // Status e Períodos
  status      SubscriptionStatus @default(TRIAL)
  startDate   DateTime           @default(now()) @map("start_date")
  validUntil  DateTime?          @map("valid_until") // Fim do período pago ou trial
  trialEndsAt DateTime?          @map("trial_ends_at") // Se estiver em período de teste

  // Uso
  queriesUsed  Int @default(0) @map("queries_used")
  queriesLimit Int @map("queries_limit")

  // Flags
  isLifetime Boolean @default(false) @map("is_lifetime")
  isTrial    Boolean @default(false) @map("is_trial")

  // Integração com Provedor de Pagamento
  externalProvider String? @map("external_provider") // STRIPE, KIWIFY, ASAAS
  externalSubId    String? @map("external_sub_id") // ID da assinatura no provedor
  kiwifyOrderId    String? @unique @map("kiwify_order_id")
  kiwifyCustomerId String? @map("kiwify_customer_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan Plan @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([status])
  @@index([validUntil])
  @@map("subscriptions")
}

enum SubscriptionStatus {
  TRIAL // Período de teste
  ACTIVE // Ativa e paga
  PAST_DUE // Pagamento atrasado
  CANCELLED // Cancelada pelo usuário
  EXPIRED // Expirada por falta de pagamento
  SUSPENDED // Suspensa por violação
}

// ============================================
// CUPONS
// ============================================

model Coupon {
  id          String  @id @default(cuid())
  code        String  @unique
  description String?

  // Tipo e Valor do Desconto (usado quando purpose=DISCOUNT ou null)
  discountType  String @map("discount_type") // PERCENT, FIXED
  discountValue Int    @map("discount_value") // Porcentagem (0-100) ou valor em centavos

  // Finalidade do Cupom (FASE: CUPONS DE UPGRADE)
  // null ou DISCOUNT = desconto financeiro (comportamento padrão/legado)
  // TRIAL_UPGRADE = libera acesso premium temporário
  purpose      String? @map("purpose") // DISCOUNT, TRIAL_UPGRADE
  durationDays Int?    @map("duration_days") // Duração em dias (usado apenas se purpose=TRIAL_UPGRADE, 1-60 dias)
  isLifetime   Boolean @default(false) @map("is_lifetime") // Se true, cria assinatura vitalícia (sem expiração)

  // Restrições
  appliesToPlanId String?   @map("applies_to_plan_id") // Se null, vale para qualquer plano
  maxUses         Int?      @map("max_uses") // Máximo de usos (null = ilimitado)
  usedCount       Int       @default(0) @map("used_count")
  expiresAt       DateTime? @map("expires_at")

  // Controle
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  plan      Plan?         @relation(fields: [appliesToPlanId], references: [id])
  usageLogs CouponUsage[]

  @@map("coupons")
}

model CouponUsage {
  id       String   @id @default(cuid())
  couponId String   @map("coupon_id")
  userId   String   @map("user_id")
  usedAt   DateTime @default(now()) @map("used_at")

  // Relações
  coupon Coupon @relation(fields: [couponId], references: [id])

  @@index([couponId])
  @@index([userId])
  @@map("coupon_usage")
}

// Rastreamento de cupons validados (para analytics e notificações de abandono)
model CouponValidation {
  id                   String    @id @default(cuid())
  couponId             String    @map("coupon_id")
  userId               String?   @map("user_id") // Nullable para usuários não logados
  userEmail            String?   @map("user_email") // Email para envio de notificação
  purpose              String    // DISCOUNT ou TRIAL_UPGRADE
  location             String    // plans_page, checkout, etc
  converted            Boolean   @default(false) // True se o cupom foi usado (checkout completado)
  reminderSentAt       DateTime? @map("reminder_sent_at") // Quando 1º email foi enviado (24h)
  secondReminderSentAt DateTime? @map("second_reminder_sent_at") // Quando 2º email foi enviado (48h)
  createdAt            DateTime  @default(now()) @map("created_at")
  updatedAt            DateTime  @updatedAt @map("updated_at")

  @@index([couponId])
  @@index([userId])
  @@index([converted])
  @@index([createdAt])
  @@index([reminderSentAt])
  @@map("coupon_validations")
}

// Subscrições de Push Notification (Web Push API)
model PushSubscription {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  endpoint   String   @unique // URL do push service
  p256dh     String   // Chave pública para criptografia
  auth       String   // Chave de autenticação
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("push_subscriptions")
}

// ============================================
// MONITORES
// ============================================

enum MonitorSite {
  MERCADO_LIVRE
  OLX
  FACEBOOK_MARKETPLACE // Mantido por compatibilidade - Scraper não disponível
  WEBMOTORS // Portal de veículos
  ICARROS // Portal de veículos
  ZAP_IMOVEIS // Portal de imóveis
  VIVA_REAL // Portal de imóveis
  IMOVELWEB // Portal de imóveis
  LEILAO // Sites de leilão (Superbid, VIP Leilões, Sodré Santoro, etc)
  OUTRO // Outros sites
}

enum MonitorMode {
  URL_ONLY // Apenas URL simples
  STRUCTURED_FILTERS // Filtros estruturados (leilões, imóveis)
}

model Monitor {
  id     String      @id @default(cuid())
  userId String      @map("user_id")
  name   String
  site   MonitorSite

  // Modos de Busca
  mode        MonitorMode @default(URL_ONLY)
  searchUrl   String?     @map("search_url") // Obrigatório se mode = URL_ONLY
  filtersJson Json?       @map("filters_json") // Obrigatório se mode = STRUCTURED_FILTERS

  // Filtros de Preço (comuns a todos)
  priceMin Float? @map("price_min")
  priceMax Float? @map("price_max")

  // Campos adicionais (compatibilidade com worker)
  keywords        String[] @default([])
  excludeKeywords String[] @default([]) @map("exclude_keywords")
  checkInterval   Int      @default(60) @map("check_interval")

  // Controle de Estado
  active         Boolean   @default(true)
  lastCheckedAt  DateTime? @map("last_checked_at")
  lastResultHash String?   @map("last_result_hash") // Hash para detectar mudanças
  lastAlertAt    DateTime? @map("last_alert_at")
  alertsEnabled  Boolean   @default(true) @map("alerts_enabled")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  user               User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  adsSeen            AdSeen[]
  logs               MonitorLog[]
  siteExecutionStats SiteExecutionStats[]

  @@index([userId])
  @@index([active])
  @@index([site])
  @@map("monitors")
}

// ============================================
// ANÚNCIOS VISTOS
// ============================================

model AdSeen {
  id          String    @id @default(cuid())
  monitorId   String    @map("monitor_id")
  externalId  String    @map("external_id")
  title       String
  description String?
  price       Float?
  url         String
  imageUrl    String?   @map("image_url")
  location    String?
  publishedAt DateTime? @map("published_at")
  firstSeenAt DateTime  @default(now()) @map("first_seen_at")
  lastSeenAt  DateTime  @default(now()) @map("last_seen_at")
  alertSent   Boolean   @default(false) @map("alert_sent")
  alertSentAt DateTime? @map("alert_sent_at")
  metadata    Json?

  // Relações
  monitor Monitor @relation(fields: [monitorId], references: [id], onDelete: Cascade)

  @@unique([monitorId, externalId])
  @@index([monitorId])
  @@map("ads_seen")
}

// ============================================
// LOGS DE EXECUÇÃO
// ============================================

model MonitorLog {
  id            String    @id @default(cuid())
  monitorId     String    @map("monitor_id")
  status        LogStatus
  adsFound      Int       @default(0) @map("ads_found")
  newAds        Int       @default(0) @map("new_ads")
  alertsSent    Int       @default(0) @map("alerts_sent")
  error         String?
  executionTime Int?      @map("execution_time")
  diagnosis     Json?     // DiagnosisRecord structured diagnosis
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relações
  monitor Monitor @relation(fields: [monitorId], references: [id], onDelete: Cascade)

  @@index([monitorId])
  @@index([createdAt])
  @@map("monitor_logs")
}

enum LogStatus {
  SUCCESS
  ERROR
  PARTIAL
  SKIPPED  // Monitor pulado por falta de sessão ou needs_reauth (NÃO é erro)
}

// ============================================
// SESSÕES DE LOGIN POR USUÁRIO (Para sites que exigem autenticação)
// ============================================

enum UserSessionStatus {
  ACTIVE      // Sessão válida e funcionando
  EXPIRED     // Expirou por tempo
  NEEDS_REAUTH // Site pediu login novamente
  INVALID     // Arquivo inválido/corrompido
}

model UserSession {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  site        String   // Ex: "MERCADO_LIVRE", "SUPERBID"
  domain      String   // Ex: "mercadolivre.com.br"
  accountLabel String? @map("account_label") // Rótulo para múltiplas contas (futuro)

  // Status da sessão (novo sistema)
  status      UserSessionStatus @default(ACTIVE)

  // Dados criptografados - NOVO SISTEMA (AES-256-GCM)
  // Formato: storageState completo do Playwright { cookies: [], origins: [] }
  encryptedStorageState String? @map("encrypted_storage_state") @db.Text

  // Campos para sistema LEGADO (mantidos para compatibilidade)
  cookies     Json?    // Usado pelo session-manager.ts legado
  localStorage Json?   @map("local_storage")

  // Metadados
  metadata    Json?    // cookieCount, uploadedAt, lastErrorReason, cooldownNotifiedAt, etc.

  // Controle de tempo
  expiresAt   DateTime? @map("expires_at")
  lastUsedAt  DateTime? @default(now()) @map("last_used_at")
  lastErrorAt DateTime? @map("last_error_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Índice único LEGADO (usado por session-manager.ts)
  @@unique([userId, site, domain])
  @@index([userId])
  @@index([site, status])
  @@index([expiresAt])
  @@map("user_sessions")
}

// ============================================
// HISTÓRICO DE USO
// ============================================

model UsageLog {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  action      String
  details     Json?
  queriesUsed Int      @default(1) @map("queries_used")
  createdAt   DateTime @default(now()) @map("created_at")

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@map("usage_logs")
}

// ============================================
// WEBHOOKS KIWIFY
// ============================================

model WebhookLog {
  id        String   @id @default(cuid())
  event     String
  payload   Json
  processed Boolean  @default(false)
  error     String?
  createdAt DateTime @default(now()) @map("created_at")

  @@index([event])
  @@index([processed])
  @@map("webhook_logs")
}

// ============================================
// HISTÓRICO DE NOTIFICAÇÕES
// ============================================

enum NotificationChannel {
  EMAIL
  TELEGRAM
}

enum NotificationStatus {
  SUCCESS
  FAILED
}

model NotificationLog {
  id        String              @id @default(cuid())
  userId    String              @map("user_id")
  channel   NotificationChannel
  title     String
  message   String              @db.Text // Texto resumido da notificação
  target    String // Email ou chatId mascarado (ex: "w***@gmail.com" ou "***1234")
  status    NotificationStatus
  error     String?             @db.Text // Mensagem de erro, se houver
  createdAt DateTime            @default(now()) @map("created_at")

  // Relações
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@index([status])
  @@map("notification_logs")
}

// ============================================
// TOKENS DE CONEXÃO TELEGRAM
// ============================================

model TelegramConnectToken {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  token     String   @unique // Token único para deep link
  status    TokenStatus @default(PENDING)
  expiresAt DateTime @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([status])
  @@index([expiresAt])
  @@map("telegram_connect_tokens")
}

enum TokenStatus {
  PENDING
  USED
  EXPIRED
}

// ============================================
// SUPORTE / FALE CONOSCO
// ============================================

model SupportTicket {
  id            String   @id @default(cuid())
  userId        String?  @map("user_id") // Nullable para usuários não logados
  email         String
  category      String
  subject       String
  message       String   @db.Text
  attachmentUrl String?  @map("attachment_url")
  status        TicketStatus @default(OPEN)
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("support_tickets")
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

// ============================================
// AUDIT LOG (FASE 3.1)
// ============================================

model AuditLog {
  id         String   @id @default(cuid())
  adminId    String   @map("admin_id")
  adminEmail String   @map("admin_email")
  action     String // USER_BLOCKED, USER_UNBLOCKED, SUBSCRIPTION_UPDATED, etc
  targetType String   @map("target_type") // USER, SUBSCRIPTION, COUPON, MONITOR, SYSTEM
  targetId   String?  @map("target_id") // ID da entidade afetada (nullable para ações globais)
  beforeData Json?    @map("before_data") // Estado antes da mudança
  afterData  Json?    @map("after_data") // Estado depois da mudança
  ipAddress  String?  @map("ip_address")
  userAgent  String?  @map("user_agent")
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([adminId])
  @@index([action])
  @@index([targetType])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================
// SYSTEM SETTINGS (FASE 3.5)
// ============================================

model SystemSetting {
  id          String   @id @default(cuid())
  key         String   @unique // MAINTENANCE_MODE, MAX_MONITORS_GLOBAL, etc
  value       String // Valor armazenado como string (parse conforme tipo)
  type        String   @default("STRING") // STRING, NUMBER, BOOLEAN, JSON
  description String? // Descrição do que essa configuração faz
  category    String   @default("GENERAL") // GENERAL, LIMITS, FEATURES, MAINTENANCE
  isPublic    Boolean  @default(false) @map("is_public") // Se pode ser exibido publicamente
  updatedBy   String?  @map("updated_by") // ID do admin que atualizou
  updatedAt   DateTime @updatedAt @map("updated_at")
  createdAt   DateTime @default(now()) @map("created_at")

  @@index([key])
  @@index([category])
  @@map("system_settings")
}

// ============================================
// ADMIN ALERTS (FASE 3.6)
// ============================================

model AdminAlert {
  id        String       @id @default(cuid())
  type      String // JOB_FAILURE, WEBHOOK_ERROR, SPIKE_MONITORS, MASS_EXPIRATION
  severity  AlertSeverity @default(INFO)
  title     String
  message   String       @db.Text
  source    String? // Nome do job, webhook, etc que gerou o alerta
  metadata  Json? // Dados adicionais (erro, contagem, etc)
  isRead    Boolean      @default(false) @map("is_read")
  readBy    String?      @map("read_by") // ID do admin que leu
  readAt    DateTime?    @map("read_at")
  createdAt DateTime     @default(now()) @map("created_at")

  @@index([isRead])
  @@index([severity])
  @@index([createdAt])
  @@map("admin_alerts")
}

enum AlertSeverity {
  INFO
  WARNING
  ERROR
  CRITICAL
}

// ============================================
// JOB RUNS (Histórico de Execução de Jobs)
// ============================================

/**
 * Registro de execução de jobs agendados
 * Cada execução de job cria um registro nesta tabela
 */
model JobRun {
  id            String       @id @default(cuid())
  jobName       String       @map("job_name") // checkTrialExpiring, resetMonthlyQueries, etc
  status        JobRunStatus @default(RUNNING)

  // Timing
  startedAt     DateTime     @default(now()) @map("started_at")
  completedAt   DateTime?    @map("completed_at")
  durationMs    Int?         @map("duration_ms") // Duração em milissegundos

  // Resultados
  processedCount Int         @default(0) @map("processed_count") // Registros processados
  successCount   Int         @default(0) @map("success_count") // Operações bem-sucedidas
  errorCount     Int         @default(0) @map("error_count") // Erros encontrados

  // Detalhes
  summary       String?      @db.Text // Resumo da execução
  errorMessage  String?      @map("error_message") @db.Text // Mensagem de erro se falhou
  metadata      Json?        // Dados adicionais (emails enviados, etc)

  // Controle
  triggeredBy   String?      @map("triggered_by") // SCHEDULER, MANUAL, API

  createdAt     DateTime     @default(now()) @map("created_at")

  @@index([jobName])
  @@index([status])
  @@index([startedAt])
  @@index([createdAt])
  @@map("job_runs")
}

enum JobRunStatus {
  RUNNING   // Em execução
  SUCCESS   // Concluído com sucesso
  PARTIAL   // Concluído com alguns erros
  FAILED    // Falhou completamente
  TIMEOUT   // Timeout
}

// ============================================
// AUTENTICAÇÃO DE SCRAPERS (Pool de Contas)
// ============================================

/**
 * Conta de autenticação para scrapers
 * Pool de contas por site para distribuição de carga
 */
model ScraperAccount {
  id       String @id @default(cuid())
  site     String // MERCADO_LIVRE, SUPERBID, etc
  label    String // Nome amigável (ex: "ML Account 1")

  // Credenciais (criptografadas)
  username       String // Email ou username
  passwordEnc    String @map("password_enc") // Senha criptografada (AES-256)
  totpSecretEnc  String? @map("totp_secret_enc") // Segredo TOTP criptografado
  otpEmail       String? @map("otp_email") // Email para receber OTP (se diferente)
  otpEmailPwdEnc String? @map("otp_email_pwd_enc") // Senha do email OTP

  // Tipo de MFA configurado
  mfaType ScraperMFAType @default(NONE) @map("mfa_type")

  // Status operacional
  status        ScraperAccountStatus @default(OK)
  statusMessage String?              @map("status_message")

  // Controle de uso
  priority            Int       @default(0) // Maior = mais preferido
  lastSuccessAt       DateTime? @map("last_success_at")
  lastFailureAt       DateTime? @map("last_failure_at")
  consecutiveFailures Int       @default(0) @map("consecutive_failures")

  // Limites e Rate Limiting
  maxRequestsPerHour Int @default(100) @map("max_requests_per_hour")
  requestsThisHour   Int @default(0) @map("requests_this_hour")
  hourResetAt        DateTime? @map("hour_reset_at")

  // Controle
  isActive  Boolean  @default(true) @map("is_active")
  metadata  Json? // Dados adicionais
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  sessions  ScraperSession[]
  authLogs  ScraperAuthLog[]

  @@unique([site, username])
  @@index([site])
  @@index([status])
  @@index([isActive])
  @@map("scraper_accounts")
}

enum ScraperMFAType {
  NONE
  TOTP
  EMAIL_OTP
  SMS_OTP
  APP_APPROVAL
}

enum ScraperAccountStatus {
  OK // Funcionando normalmente
  DEGRADED // Com problemas intermitentes
  NEEDS_REAUTH // Requer intervenção humana
  BLOCKED // Bloqueada pelo site
  SITE_CHANGED // Site mudou, fluxo precisa update
  DISABLED // Desabilitada manualmente
}

/**
 * Estado de sessão de um scraper account
 */
model ScraperSession {
  id        String @id @default(cuid())
  accountId String @map("account_id")

  // Estado da sessão
  isAuthenticated   Boolean   @default(false) @map("is_authenticated")
  lastValidatedAt   DateTime? @map("last_validated_at")
  expiresAt         DateTime? @map("expires_at")

  // Caminho do userDataDir (persistente)
  userDataDir String @map("user_data_dir")

  // Metadata
  userAgent   String? @map("user_agent")
  lastUrl     String? @map("last_url")
  cookieCount Int     @default(0) @map("cookie_count")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relações
  account ScraperAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId])
  @@index([isAuthenticated])
  @@map("scraper_sessions")
}

/**
 * Log de eventos de autenticação de scrapers
 */
model ScraperAuthLog {
  id        String @id @default(cuid())
  accountId String @map("account_id")

  // Evento
  event   String // AUTH_OK, AUTH_FAILED, AUTH_RENEW, MFA_REQUIRED, etc
  success Boolean
  message String?

  // Contexto
  url       String?
  pageType  String? @map("page_type") // LOGIN_PAGE, MFA_PAGE, CONTENT, etc
  duration  Int? // Duração em ms

  // Não logar credenciais - apenas metadados seguros
  metadata Json?

  createdAt DateTime @default(now()) @map("created_at")

  // Relações
  account ScraperAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([event])
  @@index([createdAt])
  @@map("scraper_auth_logs")
}

// ============================================
// SITE EXECUTION STATS (Observabilidade)
// ============================================

enum PageType {
  CONTENT
  BLOCKED
  CAPTCHA
  LOGIN_REQUIRED
  CHECKPOINT
  NO_RESULTS
  EMPTY
  UNKNOWN
  ERROR
}

model SiteExecutionStats {
  id          String      @id @default(cuid())
  site        MonitorSite
  monitorId   String      @map("monitor_id")
  userId      String      @map("user_id")
  startedAt   DateTime    @map("started_at")
  finishedAt  DateTime    @map("finished_at")
  durationMs  Int         @map("duration_ms")
  pageType    PageType    @map("page_type")
  adsFound    Int         @default(0) @map("ads_found")
  success     Boolean     @default(false)
  errorCode   String?     @map("error_code")
  createdAt   DateTime    @default(now()) @map("created_at")

  monitor     Monitor     @relation(fields: [monitorId], references: [id], onDelete: Cascade)
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([site])
  @@index([createdAt])
  @@index([success])
  @@index([site, createdAt])
  @@map("site_execution_stats")
}
